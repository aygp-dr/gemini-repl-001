#+TITLE: NODE-SETUP.org - ClojureScript Development Environment
#+AUTHOR: jwalsh + Claude
#+DATE: 2025-07-14
#+STARTUP: overview

* ClojureScript Development Environment

This file sets up the complete ClojureScript development environment using Shadow-CLJS and Node.js.

** Package Configuration

#+BEGIN_SRC json :tangle package.json
{
  "name": "gemini-repl",
  "version": "0.1.0",
  "description": "Simple REPL interface for Gemini API in ClojureScript",
  "main": "target/main.js",
  "scripts": {
    "dev": "shadow-cljs watch app",
    "build": "shadow-cljs release app",
    "clean": "rm -rf target .shadow-cljs",
    "test": "shadow-cljs compile test && node target/test.js",
    "repl": "shadow-cljs cljs-repl app"
  },
  "keywords": ["clojurescript", "gemini", "repl", "api"],
  "author": "jwalsh",
  "license": "MIT",
  "devDependencies": {
    "shadow-cljs": "^2.27.4"
  },
  "dependencies": {}
}
#+END_SRC

** Shadow-CLJS Configuration

#+BEGIN_SRC clojure :tangle shadow-cljs.edn
{:source-paths ["src"]
 
 :dependencies []
 
 :builds
 {:app
  {:target :node-script
   :output-to "target/main.js"
   :main gemini-repl.core/main
   :devtools {:after-load gemini-repl.core/reload}}
  
  :test
  {:target :node-test
   :output-to "target/test.js"
   :ns-regexp "-test$"
   :autorun true}}}
#+END_SRC

** Core Implementation

#+BEGIN_SRC clojure :tangle src/gemini_repl/core.cljs
(ns gemini-repl.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(def readline (nodejs/require "readline"))
(def process (nodejs/require "process"))
(def https (nodejs/require "https"))

(defonce rl (atom nil))

;; Configuration
(def api-key (or (.-GEMINI_API_KEY (.-env process))
                 (throw (js/Error. "GEMINI_API_KEY environment variable is required"))))

(def api-endpoint "generativelanguage.googleapis.com")

;; Commands
(defn show-help []
  (println "
Gemini REPL Commands:
  /help    - Show this help message
  /exit    - Exit the REPL
  /clear   - Clear the screen
  /stats   - Show session statistics
  
Type your prompt and press Enter to send to Gemini API."))

(defn clear-screen []
  (print "\033[2J\033[H"))

(defn show-stats []
  (println "\nSession Statistics:")
  (println "  Total requests: 0")
  (println "  Total tokens: 0")
  (println "  Session time: 0 minutes"))

;; API Communication
(defn make-request [prompt callback]
  (let [data (js/JSON.stringify
              #js {:contents
                   #js [#js {:parts
                             #js [#js {:text prompt}]}]})
        options #js {:hostname api-endpoint
                     :port 443
                     :path (str "/v1beta/models/gemini-1.5-flash:generateContent?key=" api-key)
                     :method "POST"
                     :headers #js {"Content-Type" "application/json"
                                   "Content-Length" (.-length data)}}]
    
    (let [req (.request https options
                        (fn [res]
                          (let [chunks (atom [])]
                            (.on res "data" (fn [chunk]
                                              (swap! chunks conj chunk)))
                            (.on res "end" (fn []
                                             (let [body (.toString (.concat js/Buffer @chunks))
                                                   response (js/JSON.parse body)]
                                               (callback response)))))))]
      (.on req "error" (fn [e]
                         (println "Error:" (.-message e))
                         (callback nil)))
      (.write req data)
      (.end req))))

(defn format-response [response]
  (if response
    (try
      (let [candidates (.-candidates response)
            content (-> candidates
                       (aget 0)
                       (.-content)
                       (.-parts)
                       (aget 0)
                       (.-text))]
        content)
      (catch js/Error e
        (str "Error parsing response: " (.-message e))))
    "No response received"))

;; REPL Loop
(defn process-input [input]
  (let [trimmed (.trim input)]
    (cond
      (= trimmed "/help") (show-help)
      (= trimmed "/exit") (do
                            (println "Goodbye!")
                            (.close @rl)
                            (.exit process 0))
      (= trimmed "/clear") (clear-screen)
      (= trimmed "/stats") (show-stats)
      (empty? trimmed) nil
      :else (do
              (print "\nGemini: ")
              (make-request trimmed
                            (fn [response]
                              (println (format-response response))
                              (print "\n> ")
                              (.prompt @rl true)))))))

(defn show-banner []
  (println "
╔═══════════════════════════════════╗
║        GEMINI REPL v0.1.0         ║
║   ClojureScript + Gemini API      ║
╚═══════════════════════════════════╝

Type /help for commands, /exit to quit.
"))

(defn -main [& args]
  (show-banner)
  (let [rl-interface (.createInterface readline
                                       #js {:input (.-stdin process)
                                            :output (.-stdout process)
                                            :prompt "> "})]
    (reset! rl rl-interface)
    
    (.on rl-interface "line"
         (fn [line]
           (process-input line)))
    
    (.on rl-interface "close"
         (fn []
           (println "\nGoodbye!")
           (.exit process 0)))
    
    (.prompt rl-interface)))

(defn reload []
  (println "Code reloaded!"))

(set! *main-cli-fn* -main)
#+END_SRC

** Test Setup

#+BEGIN_SRC clojure :tangle test/gemini_repl/core_test.cljs
(ns gemini-repl.core-test
  (:require [cljs.test :refer-macros [deftest is testing]]
            [gemini-repl.core :as core]))

(deftest format-response-test
  (testing "Format valid response"
    (let [mock-response #js {:candidates #js [#js {:content
                                                    #js {:parts
                                                         #js [#js {:text "Hello from Gemini!"}]}}]}]
      (is (= "Hello from Gemini!" (core/format-response mock-response)))))
  
  (testing "Handle nil response"
    (is (= "No response received" (core/format-response nil))))
  
  (testing "Handle malformed response"
    (is (string? (core/format-response #js {})))))

(deftest api-key-test
  (testing "API key is configured"
    (is (string? core/api-key))))
#+END_SRC

** Development Scripts

#+BEGIN_SRC bash :tangle scripts/dev.sh :shebang #!/bin/bash
# Development script for Gemini REPL

echo "Starting Shadow-CLJS development server..."
npm run dev
#+END_SRC

#+BEGIN_SRC bash :tangle scripts/build.sh :shebang #!/bin/bash
# Build script for Gemini REPL

echo "Building production release..."
npm run build

if [ -f target/main.js ]; then
    echo "Build successful!"
    echo "Run with: node target/main.js"
else
    echo "Build failed!"
    exit 1
fi
#+END_SRC

#+BEGIN_SRC bash :tangle scripts/run.sh :shebang #!/bin/bash
# Run the Gemini REPL

if [ ! -f target/main.js ]; then
    echo "Building first..."
    npm run build
fi

if [ -z "$GEMINI_API_KEY" ]; then
    echo "Error: GEMINI_API_KEY environment variable is required"
    exit 1
fi

node target/main.js
#+END_SRC

** Update Makefile

#+BEGIN_SRC makefile :tangle Makefile
.PHONY: help setup build dev run test clean lint verify install

help:
	@echo "Available targets:"
	@echo "  install  - Install npm dependencies"
	@echo "  setup    - Create directory structure"
	@echo "  build    - Build the project"
	@echo "  dev      - Start development server"
	@echo "  run      - Run the REPL"
	@echo "  test     - Run tests"
	@echo "  lint     - Run linter"
	@echo "  verify   - Verify formal specifications"
	@echo "  clean    - Clean build artifacts"

install:
	@npm install
	@echo "Dependencies installed"

setup:
	@bash create-dirs.sh
	@echo "Directory structure created"

build: install
	@npm run build

dev: install
	@npm run dev

run: build
	@bash scripts/run.sh

test: install
	@npm test

lint:
	@echo "Linting ClojureScript files..."
	@npx clj-kondo --lint src test || true

verify:
	@echo "Verification target - to be implemented"

clean:
	@npm run clean
	@rm -rf node_modules
	@echo "Cleaned build artifacts"
#+END_SRC